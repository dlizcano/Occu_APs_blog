{"title":"Fitting a Multi-Species non Spatial Occupancy Model","markdown":{"yaml":{"title":"Fitting a Multi-Species non Spatial Occupancy Model","subtitle":"Using Llanganates subset of the WCS camera trap dataset","lightbox":true,"author":[{"name":"German Forero","orcid":"https://orcid.org/0000-0001-9952-7221"},{"name":"Galo Zapara-Rios","orcid":"https://orcid.org/0000-0003-3508-5078"},{"name":"Diego J. Lizcano","orcid":"https://orcid.org/0000-0002-9648-0576"}],"toc":true,"format":{"html":{"code-fold":true,"code-block-bg":true,"code-block-border-left":"#31BAE9"}},"license":"CC BY-SA","date":"2025-05-17","execute":{"freeze":true},"citation":true,"google-scholar":true,"bibliography":"grateful-refs.bib","bibliographystyle":"https://www.zotero.org/styles/tapir-conservation","categories":["model","code","analysis"],"image":"image.png"},"headingText":"Multi-species occupancy model using CamtrapR package","containsRefs":false,"markdown":"\n\n\nMulti-species occupancy models are a powerful tool for combining information from multiple species to estimate both individual and community-level responses to environmental variables. These models are typically fit using Bayesian frameworks such as BUGS, JAGS, or Nimble. However, preparing the necessary input from camera trapping data, writing the model code, setting parameters to monitor, and providing initial values can be a daunting and time-consuming task, even for experienced users. \n\n`camtrapR` helps using custom funtions to fit community occupancy models for analysis in JAGS or Nimble with several limitations such as: models with categorical observation-level covariates cannot be compiled in Nimble and must be fit in JAGS instead. Priors can not be customized, and independent effects are only supported in continuous site covariates. \n\nIn terms of speed, Nimble does not seem to have an advantage over JAGS. \n\n```{r}\n#| echo: true\n#| code-fold: true\n#| warning: false\n#| message: false\n#| \nlibrary(grateful)\nlibrary(readxl)\nlibrary(DT)\nlibrary(sf)\nlibrary(mapview)\nlibrary(maps)\nlibrary(tmap)\nlibrary(terra)\nlibrary(elevatr)\n#library(spOccupancy)\n\nlibrary(rjags) # Bayesian Graphical Models using MCMC \nlibrary(bayesplot) # Plotting for Bayesian Models # Plotting for Bayesian Models\nlibrary(tictoc) # Functions for Timing R Scripts, as Well as Implementations of \"Stack\" and \"StackList\" Structures \nlibrary(beepr) # Easily Play Notification Sounds on any Platform \nlibrary(snowfall) # Easier Cluster Computing (Based on 'snow')\n\n#library(ggmcmc)\nlibrary(camtrapR)\nlibrary(tidyverse)\n\n```\n\n## Fitting a Multi-Species non Spatial Occupancy Model\n### Llanganates data \nHere we use the tables Ecu-14, Ecu-15  y Ecu-16.\n\n```{r}\n\nsource(\"C:/CodigoR/WCS-CameraTrap/R/organiza_datos_v3.R\")\n\nAP_Llanganates <- read_sf(\"C:/CodigoR/Occu_APs/shp/Llanganates/WDPA_WDOECM_May2025_Public_97512_shp-polygons.shp\")\n\n### Ecu 14, Ecu 15  y Ecu 16\n\n# load data and make array_locID column\nEcu_14 <- loadproject(\"F:/WCS-CameraTrap/data/BDcorregidas/Ecuador/ECU-014.xlsx\") |> mutate(array_locID=paste(\"Ecu_14\", locationID, sep=\"_\"))\nEcu_15 <- loadproject(\"F:/WCS-CameraTrap/data/BDcorregidas/Ecuador/ECU-015.xlsx\")|> mutate(array_locID=paste(\"Ecu_15\", locationID, sep=\"_\"))\nEcu_16 <- loadproject(\"F:/WCS-CameraTrap/data/BDcorregidas/Ecuador/ECU-016.xlsx\")|> mutate(array_locID=paste(\"Ecu_16\", locationID, sep=\"_\"))\n\n\n\n# get sites\nEcu_14_sites <- get.sites(\"F:/WCS-CameraTrap/data/BDcorregidas/Ecuador/ECU-014.xlsx\")\nEcu_15_sites <- get.sites(\"F:/WCS-CameraTrap/data/BDcorregidas/Ecuador/ECU-015.xlsx\")\nEcu_16_sites <- get.sites(\"F:/WCS-CameraTrap/data/BDcorregidas/Ecuador/ECU-016.xlsx\")\n\n\n\n\n# get elevation map\nelevation_14 <- rast(get_elev_raster(Ecu_14_sites, z = 7)) #z =1-14\nbb <-  st_as_sfc(st_bbox(elevation_14)) # make bounding box \n\n\n\n\n# extract covs using points and add to _sites\ncovs_Ecu_14_sites <- cbind(Ecu_14_sites, terra::extract(elevation_14, Ecu_14_sites))\n\ncovs_Ecu_15_sites <- cbind(Ecu_15_sites, terra::extract(elevation_14, Ecu_15_sites))\n\ncovs_Ecu_16_sites <- cbind(Ecu_16_sites, terra::extract(elevation_14, Ecu_16_sites))\n\n# get which are in and out\ncovs_Ecu_14_sites$in_AP = st_intersects(covs_Ecu_14_sites, AP_Llanganates, sparse = FALSE)\n\ncovs_Ecu_15_sites$in_AP = st_intersects(covs_Ecu_15_sites, AP_Llanganates, sparse = FALSE)\n\ncovs_Ecu_16_sites$in_AP = st_intersects(covs_Ecu_16_sites, AP_Llanganates, sparse = FALSE)\n\n\n\n# make a map\nmapview (elevation_14, alpha=0.5) + \n  mapview (AP_Llanganates, color = \"green\", col.regions = \"green\", alpha = 0.5) +\n  mapview (covs_Ecu_14_sites, zcol = \"in_AP\", col.regions =c(\"red\",\"blue\"), burst = TRUE) +\n  mapview (covs_Ecu_15_sites, zcol = \"in_AP\", burst = TRUE, col.regions = c(\"blue\") )+\n  mapview (covs_Ecu_16_sites, zcol = \"in_AP\", burst = TRUE, col.regions =c(\"red\",\"blue\")) \n  \n\n\n```\n\n### Camera trap operation data and detection history\n\n```{r}\n# Join 3 tables\nEcu_14_15_16 <- Ecu_14 |> full_join(Ecu_15) |> full_join(Ecu_16)\n\n# fix date format\n# \nEcu_14_15_16$start_date <- as.Date(Ecu_14_15_16$start_date, \"%Y/%m/%d\")\nEcu_14_15_16$end_date <- as.Date(Ecu_14_15_16$end_date, \"%Y/%m/%d\")\nEcu_14_15_16$eventDate <- as.Date(Ecu_14_15_16$Date_Time_Captured, \"%Y-%m-%d\")\nEcu_14_15_16$eventDateTime <- ymd_hms(Ecu_14_15_16$Date_Time_Captured)\n\n\n# filter 2021 and make uniques\nCToperation  <- Ecu_14_15_16 |> group_by(array_locID) |> \n                           mutate(minStart=start_date, maxEnd=end_date) |> distinct(Longitude, Latitude, minStart, maxEnd) |> ungroup()\n\n\n# Generamos la matríz de operación de las cámaras\n\ncamop <- cameraOperation(CTtable= CToperation, # Tabla de operación\n                         stationCol= \"array_locID\", # Columna que define la estación\n                         setupCol= \"minStart\", #Columna fecha de colocación\n                         retrievalCol= \"maxEnd\", #Columna fecha de retiro\n                         #hasProblems= T, # Hubo fallos de cámaras\n                         dateFormat= \"%Y-%m-%d\") #, # Formato de las fechas\n                         #cameraCol=\"CT\")\n                         # sessionCol= \"Year\")\n\n# Generar las historias de detección ---------------------------------------\n## remove plroblem species\nind <- which(Ecu_14_15_16$scientificName==\"Set up\")\nEcu_14_15_16 <- Ecu_14_15_16[-ind,]\n\nind <- which(Ecu_14_15_16$scientificName==\"Blank\")\nEcu_14_15_16 <- Ecu_14_15_16[-ind,]\n\nind <- which(Ecu_14_15_16$scientificName==\"Unknown\")\nEcu_14_15_16 <- Ecu_14_15_16[-ind,]\n\n\n\n\n\nDetHist_list <- lapply(unique(Ecu_14_15_16$scientificName), FUN = function(x) {\n  detectionHistory(\n    recordTable         = Ecu_14_15_16, # Tabla de registros\n    camOp                = camop, # Matriz de operación de cámaras\n    stationCol           = \"array_locID\",\n    speciesCol           = \"scientificName\",\n    recordDateTimeCol    = \"eventDateTime\",\n    recordDateTimeFormat  = \"%Y-%m-%d %H:%M:%S\",\n    species              = x,     # la función reemplaza x por cada una de las especies\n    occasionLength       = 7, # Colapso de las historias a 10 ías\n    day1                 = \"station\", # \"survey\" a specific date, \"station\", #inicie en la fecha de cada survey\n    datesAsOccasionNames = FALSE,\n    includeEffort        = TRUE,\n    scaleEffort          = TRUE,\n    #unmarkedMultFrameInput=TRUE\n    timeZone             = \"America/Bogota\" \n    )\n  }\n)\n\n# names\nnames(DetHist_list) <- unique(Ecu_14_15_16$scientificName)\n\n# Finalmente creamos una lista nueva donde estén solo las historias de detección\nylist <- lapply(DetHist_list, FUN = function(x) x$detection_history)\n# otra lista con effort scaled\nefort <- lapply(DetHist_list, FUN = function(x) x$effort)\n\n# Total number of observations for each species\nlapply(ylist, sum, na.rm = TRUE)\n\n\n\n```\n\n\n### Arrange spatial covariates\n\n```{r}\n\n# make sf()\nfull_sites_14_15_16_sf <- CToperation |> \n    st_as_sf(coords = c(\"Longitude\", \"Latitude\"), \n              crs = 4326)\n\n# extract elev\nfull_sites_14_15_16_sf$elev <- terra::extract(elevation_14, full_sites_14_15_16_sf)[,2]\nstr(full_sites_14_15_16_sf$elev)\n\n# extract in AP\nfull_sites_14_15_16_sf$in_AP = as.factor(st_intersects(full_sites_14_15_16_sf, AP_Llanganates, sparse = FALSE))\n\nin_AP <- as.numeric(as.vector(st_drop_geometry(full_sites_14_15_16_sf$in_AP)))\n\n# mapview(full_sites_14_15_16_sf, zcol = \"in_AP\", burst = TRUE)\n\n# Transform coord to UTM Z17 Ecuador EPSG:32717 WGS 84 / UTM zone 17S\nfull_sites_14_15_16_sf_UTM <- st_transform(full_sites_14_15_16_sf, \"EPSG:32717\")\n\ncoords <- st_coordinates(full_sites_14_15_16_sf_UTM)\n#str(coords)\n\n# make Ecu_14_15_16 an sf object\n#    cam_sf <- st_as_sf(Ecu_14_15_16, coords = c(\"lon\",\"lat\"))   #crs=\"EPSG:4326\")\n    #--- set CRS ---#\n#    st_crs(cam_sf) <- 4326\n\n#transform llanganates to UTM\nAP_Llanganates_UTM <- st_transform(AP_Llanganates, \"EPSG:32717\")\n# Convert to LINESTRING\nAP_Llanganates_UTM_line <- st_cast(AP_Llanganates_UTM, \"LINESTRING\")\n\n# Calculate the distance\n#multiplic <- full_sites_14_15_16_sf_UTM |> mutate(multiplic= as.numeric(in_AP)) \nmultiplic=ifelse(full_sites_14_15_16_sf_UTM$in_AP==\"TRUE\",-1,1)\nfull_sites_14_15_16_sf_UTM$border_dist <- as.numeric(st_distance(full_sites_14_15_16_sf_UTM, AP_Llanganates_UTM_line) * multiplic )\n# print(border_dist)\n\nstr(full_sites_14_15_16_sf_UTM$border_dist)\n\n                    \n\n```\n\n### Prepare the model\n\n```{r}\n# Detection-nondetection data ---------\n# Species of interest, can select individually\n# curr.sp <- sort(unique(Ecu_14_15_16$.id))# c('BAWW', 'BLJA', 'GCFL')\nselected.sp <-  c(\"Canis familiaris\", \n              \"Cuniculus paca\",\n              \"Cuniculus taczanowskii\",\n              \"Dasyprocta fuliginosa\",\n              \"Eira barbara\",\n              \"Herpailurus yagouaroundi\",\n              \"Mazama murelia\",\n              \"Mazama rufina\",\n              \"Mazama zamora\",\n              \"Nasuella olivacea\",\n              \"Odocoileus ustus\",\n              \"Pecari tajacu\",\n              \"Pseudalopex culpaeus\",\n              \"Pudu mephistophiles\",\n              \"Puma concolor\",\n              \"Tapirus pinchaque\",\n              \"Tayassu pecari\",\n              \"Tremarctos ornatus\")\n\n# y.msom <- y[which(sp.codes %in% selected.sp), , ]\n# str(y.msom)\n\n\n#### site covs\nsitecovs <- as.data.frame(st_drop_geometry(\n                    full_sites_14_15_16_sf_UTM[,5:7]))\n sitecovs[, 1] <- as.vector(scale(sitecovs[,1]))   # scale numeric covariates\n sitecovs[, 3] <- as.vector(scale(sitecovs[,3]))   # scale numeric covariates\n # sitecovs$fact <- factor(c(\"A\", \"A\", \"B\"))    # categorical covariate\n\nnames(sitecovs) <- c(\"elev\", \"in_AP\", \"border_dist\")\n\n# check consistancy equal number of spatial covariates and rows in data\n# identical(nrow(ylist[[1]]), nrow(covars)) \n\n# Base de datos para los análisis -----------------------------------------\n\ndata_list <- list(ylist    = ylist, # Historias de detección\n                  siteCovs = sitecovs, #covars, # Covariables de sitio\n                  obsCovs  = list(effort = DetHist_list[[1]]$effort))  # agregamos el esfuerzo de muestreo como covariable de observación\n\n# 3. 1 Modelo multi-especie  -----------------------------------------\n\n# Se creará un txt temporal donde estarán las especificaciones del modelo Bayesiano en JAGS\nmodelfile <- (fileext = \"modoccu.txt\")\n\n# Usaremos la función ` communityModel`\n\n# Generemos el modelo\ncomu_model <- communityModel(data_list, # la lista de datos\n                             occuCovs = list(ranef=c(\"border_dist\", \"elev\", \"in_AP\")), # ranef La covariables de sitio\n                             detCovsObservation = list(fixed = \"effort\"), #Covariables de observación\n                             intercepts = list(det = \"ranef\", occu = \"ranef\"),\n                             # augmentation = c(full = 30),# Número aumentado de especies\n                             modelFile = \"modelfile\")\n\nsummary(comu_model)\n\n\n\n```\n\n### Running the model\n\n```{r}\n# Running the model\n\nfit.commu <- fit(comu_model,\n                 n.iter = 100000,\n                 n.burnin = 10000,\n                 thin = 50,\n                 chains = 3,\n                 cores = 3,\n                 quiet = T\n);beep(sound = 4)\n\n# save the results to not run again\nsave(fit.commu, file=\"C:/CodigoR/Occu_APs/Occu_APs_blog/posts/2nd_model_1AP/result/DR_result.R\") # guardamos los resultados para no correr de nuevo\n```\n### Results as table \n\n```{r}\n\n# Resultados --------------------------------------------------------------\n\n# Extraemos lo tabla de valores estimados\nmodresult <- as.data.frame(summary(fit.commu)[[\"statistics\"]])\n# View(modresult)\nDT::datatable(round(summary(fit.commu)$statistics, 3))\n```\n \n Bayesian p-values can be inspected to check for lack of fit (overall or by species). Lack of fit at significance level = 0.05 is indicated by Bayesian p-values below 0.025 or greater than 0.975. The overall Bayesian p-value (Bpvalue) indicates no problems with lack of fit. Likewise, species-level Bayesian p-values (Bpvalue_species) indicate no lack of fit for any species.\n \n### Results as graph\n\n```{r}\n# Gráficos de predicción y de coeficientes\n\n# Otra gran ventaja de CamtrapR es que permite gráficar de manera muy sencilla la predicción posterior del modelo. Veamos que pasa con la ocupación de cada especie\n\nplot_effects(comu_model,\n              fit.commu,\n              submodel = \"det\",\n             combine = T)\n# $effort\n\n\nplot_coef(comu_model,\n           fit.commu,\n           submodel = \"state\",\n           combine = T)\n# $occupancy\n\n\n\nplot_effects(comu_model, # El modelo\n             fit.commu, # El objeto ajustado\n             submodel = \"state\",\n             response = \"occupancy\") # el parámetro de interés\n#> $rough\n#> \n\n```\n\n\nHere we should see all Rhat values are less than 1.1 and the ESS values indicating adequate mixing of the MCMC chains.\n\n\n\n\n\n\n\n\n## Package Citation\n\n```{r}\n#| code-fold: true\npkgs <- cite_packages(output = \"paragraph\", pkgs=\"Session\", out.dir = \".\")\n# knitr::kable(pkgs)\npkgs\n```\n\n## Sesion info\n\n::: {.callout-note collapse=true}\n```{r}\nprint(sessionInfo(), locale = FALSE)\n```\n:::\n\n\n","srcMarkdownNoYaml":"\n\n## Multi-species occupancy model using CamtrapR package\n\nMulti-species occupancy models are a powerful tool for combining information from multiple species to estimate both individual and community-level responses to environmental variables. These models are typically fit using Bayesian frameworks such as BUGS, JAGS, or Nimble. However, preparing the necessary input from camera trapping data, writing the model code, setting parameters to monitor, and providing initial values can be a daunting and time-consuming task, even for experienced users. \n\n`camtrapR` helps using custom funtions to fit community occupancy models for analysis in JAGS or Nimble with several limitations such as: models with categorical observation-level covariates cannot be compiled in Nimble and must be fit in JAGS instead. Priors can not be customized, and independent effects are only supported in continuous site covariates. \n\nIn terms of speed, Nimble does not seem to have an advantage over JAGS. \n\n```{r}\n#| echo: true\n#| code-fold: true\n#| warning: false\n#| message: false\n#| \nlibrary(grateful)\nlibrary(readxl)\nlibrary(DT)\nlibrary(sf)\nlibrary(mapview)\nlibrary(maps)\nlibrary(tmap)\nlibrary(terra)\nlibrary(elevatr)\n#library(spOccupancy)\n\nlibrary(rjags) # Bayesian Graphical Models using MCMC \nlibrary(bayesplot) # Plotting for Bayesian Models # Plotting for Bayesian Models\nlibrary(tictoc) # Functions for Timing R Scripts, as Well as Implementations of \"Stack\" and \"StackList\" Structures \nlibrary(beepr) # Easily Play Notification Sounds on any Platform \nlibrary(snowfall) # Easier Cluster Computing (Based on 'snow')\n\n#library(ggmcmc)\nlibrary(camtrapR)\nlibrary(tidyverse)\n\n```\n\n## Fitting a Multi-Species non Spatial Occupancy Model\n### Llanganates data \nHere we use the tables Ecu-14, Ecu-15  y Ecu-16.\n\n```{r}\n\nsource(\"C:/CodigoR/WCS-CameraTrap/R/organiza_datos_v3.R\")\n\nAP_Llanganates <- read_sf(\"C:/CodigoR/Occu_APs/shp/Llanganates/WDPA_WDOECM_May2025_Public_97512_shp-polygons.shp\")\n\n### Ecu 14, Ecu 15  y Ecu 16\n\n# load data and make array_locID column\nEcu_14 <- loadproject(\"F:/WCS-CameraTrap/data/BDcorregidas/Ecuador/ECU-014.xlsx\") |> mutate(array_locID=paste(\"Ecu_14\", locationID, sep=\"_\"))\nEcu_15 <- loadproject(\"F:/WCS-CameraTrap/data/BDcorregidas/Ecuador/ECU-015.xlsx\")|> mutate(array_locID=paste(\"Ecu_15\", locationID, sep=\"_\"))\nEcu_16 <- loadproject(\"F:/WCS-CameraTrap/data/BDcorregidas/Ecuador/ECU-016.xlsx\")|> mutate(array_locID=paste(\"Ecu_16\", locationID, sep=\"_\"))\n\n\n\n# get sites\nEcu_14_sites <- get.sites(\"F:/WCS-CameraTrap/data/BDcorregidas/Ecuador/ECU-014.xlsx\")\nEcu_15_sites <- get.sites(\"F:/WCS-CameraTrap/data/BDcorregidas/Ecuador/ECU-015.xlsx\")\nEcu_16_sites <- get.sites(\"F:/WCS-CameraTrap/data/BDcorregidas/Ecuador/ECU-016.xlsx\")\n\n\n\n\n# get elevation map\nelevation_14 <- rast(get_elev_raster(Ecu_14_sites, z = 7)) #z =1-14\nbb <-  st_as_sfc(st_bbox(elevation_14)) # make bounding box \n\n\n\n\n# extract covs using points and add to _sites\ncovs_Ecu_14_sites <- cbind(Ecu_14_sites, terra::extract(elevation_14, Ecu_14_sites))\n\ncovs_Ecu_15_sites <- cbind(Ecu_15_sites, terra::extract(elevation_14, Ecu_15_sites))\n\ncovs_Ecu_16_sites <- cbind(Ecu_16_sites, terra::extract(elevation_14, Ecu_16_sites))\n\n# get which are in and out\ncovs_Ecu_14_sites$in_AP = st_intersects(covs_Ecu_14_sites, AP_Llanganates, sparse = FALSE)\n\ncovs_Ecu_15_sites$in_AP = st_intersects(covs_Ecu_15_sites, AP_Llanganates, sparse = FALSE)\n\ncovs_Ecu_16_sites$in_AP = st_intersects(covs_Ecu_16_sites, AP_Llanganates, sparse = FALSE)\n\n\n\n# make a map\nmapview (elevation_14, alpha=0.5) + \n  mapview (AP_Llanganates, color = \"green\", col.regions = \"green\", alpha = 0.5) +\n  mapview (covs_Ecu_14_sites, zcol = \"in_AP\", col.regions =c(\"red\",\"blue\"), burst = TRUE) +\n  mapview (covs_Ecu_15_sites, zcol = \"in_AP\", burst = TRUE, col.regions = c(\"blue\") )+\n  mapview (covs_Ecu_16_sites, zcol = \"in_AP\", burst = TRUE, col.regions =c(\"red\",\"blue\")) \n  \n\n\n```\n\n### Camera trap operation data and detection history\n\n```{r}\n# Join 3 tables\nEcu_14_15_16 <- Ecu_14 |> full_join(Ecu_15) |> full_join(Ecu_16)\n\n# fix date format\n# \nEcu_14_15_16$start_date <- as.Date(Ecu_14_15_16$start_date, \"%Y/%m/%d\")\nEcu_14_15_16$end_date <- as.Date(Ecu_14_15_16$end_date, \"%Y/%m/%d\")\nEcu_14_15_16$eventDate <- as.Date(Ecu_14_15_16$Date_Time_Captured, \"%Y-%m-%d\")\nEcu_14_15_16$eventDateTime <- ymd_hms(Ecu_14_15_16$Date_Time_Captured)\n\n\n# filter 2021 and make uniques\nCToperation  <- Ecu_14_15_16 |> group_by(array_locID) |> \n                           mutate(minStart=start_date, maxEnd=end_date) |> distinct(Longitude, Latitude, minStart, maxEnd) |> ungroup()\n\n\n# Generamos la matríz de operación de las cámaras\n\ncamop <- cameraOperation(CTtable= CToperation, # Tabla de operación\n                         stationCol= \"array_locID\", # Columna que define la estación\n                         setupCol= \"minStart\", #Columna fecha de colocación\n                         retrievalCol= \"maxEnd\", #Columna fecha de retiro\n                         #hasProblems= T, # Hubo fallos de cámaras\n                         dateFormat= \"%Y-%m-%d\") #, # Formato de las fechas\n                         #cameraCol=\"CT\")\n                         # sessionCol= \"Year\")\n\n# Generar las historias de detección ---------------------------------------\n## remove plroblem species\nind <- which(Ecu_14_15_16$scientificName==\"Set up\")\nEcu_14_15_16 <- Ecu_14_15_16[-ind,]\n\nind <- which(Ecu_14_15_16$scientificName==\"Blank\")\nEcu_14_15_16 <- Ecu_14_15_16[-ind,]\n\nind <- which(Ecu_14_15_16$scientificName==\"Unknown\")\nEcu_14_15_16 <- Ecu_14_15_16[-ind,]\n\n\n\n\n\nDetHist_list <- lapply(unique(Ecu_14_15_16$scientificName), FUN = function(x) {\n  detectionHistory(\n    recordTable         = Ecu_14_15_16, # Tabla de registros\n    camOp                = camop, # Matriz de operación de cámaras\n    stationCol           = \"array_locID\",\n    speciesCol           = \"scientificName\",\n    recordDateTimeCol    = \"eventDateTime\",\n    recordDateTimeFormat  = \"%Y-%m-%d %H:%M:%S\",\n    species              = x,     # la función reemplaza x por cada una de las especies\n    occasionLength       = 7, # Colapso de las historias a 10 ías\n    day1                 = \"station\", # \"survey\" a specific date, \"station\", #inicie en la fecha de cada survey\n    datesAsOccasionNames = FALSE,\n    includeEffort        = TRUE,\n    scaleEffort          = TRUE,\n    #unmarkedMultFrameInput=TRUE\n    timeZone             = \"America/Bogota\" \n    )\n  }\n)\n\n# names\nnames(DetHist_list) <- unique(Ecu_14_15_16$scientificName)\n\n# Finalmente creamos una lista nueva donde estén solo las historias de detección\nylist <- lapply(DetHist_list, FUN = function(x) x$detection_history)\n# otra lista con effort scaled\nefort <- lapply(DetHist_list, FUN = function(x) x$effort)\n\n# Total number of observations for each species\nlapply(ylist, sum, na.rm = TRUE)\n\n\n\n```\n\n\n### Arrange spatial covariates\n\n```{r}\n\n# make sf()\nfull_sites_14_15_16_sf <- CToperation |> \n    st_as_sf(coords = c(\"Longitude\", \"Latitude\"), \n              crs = 4326)\n\n# extract elev\nfull_sites_14_15_16_sf$elev <- terra::extract(elevation_14, full_sites_14_15_16_sf)[,2]\nstr(full_sites_14_15_16_sf$elev)\n\n# extract in AP\nfull_sites_14_15_16_sf$in_AP = as.factor(st_intersects(full_sites_14_15_16_sf, AP_Llanganates, sparse = FALSE))\n\nin_AP <- as.numeric(as.vector(st_drop_geometry(full_sites_14_15_16_sf$in_AP)))\n\n# mapview(full_sites_14_15_16_sf, zcol = \"in_AP\", burst = TRUE)\n\n# Transform coord to UTM Z17 Ecuador EPSG:32717 WGS 84 / UTM zone 17S\nfull_sites_14_15_16_sf_UTM <- st_transform(full_sites_14_15_16_sf, \"EPSG:32717\")\n\ncoords <- st_coordinates(full_sites_14_15_16_sf_UTM)\n#str(coords)\n\n# make Ecu_14_15_16 an sf object\n#    cam_sf <- st_as_sf(Ecu_14_15_16, coords = c(\"lon\",\"lat\"))   #crs=\"EPSG:4326\")\n    #--- set CRS ---#\n#    st_crs(cam_sf) <- 4326\n\n#transform llanganates to UTM\nAP_Llanganates_UTM <- st_transform(AP_Llanganates, \"EPSG:32717\")\n# Convert to LINESTRING\nAP_Llanganates_UTM_line <- st_cast(AP_Llanganates_UTM, \"LINESTRING\")\n\n# Calculate the distance\n#multiplic <- full_sites_14_15_16_sf_UTM |> mutate(multiplic= as.numeric(in_AP)) \nmultiplic=ifelse(full_sites_14_15_16_sf_UTM$in_AP==\"TRUE\",-1,1)\nfull_sites_14_15_16_sf_UTM$border_dist <- as.numeric(st_distance(full_sites_14_15_16_sf_UTM, AP_Llanganates_UTM_line) * multiplic )\n# print(border_dist)\n\nstr(full_sites_14_15_16_sf_UTM$border_dist)\n\n                    \n\n```\n\n### Prepare the model\n\n```{r}\n# Detection-nondetection data ---------\n# Species of interest, can select individually\n# curr.sp <- sort(unique(Ecu_14_15_16$.id))# c('BAWW', 'BLJA', 'GCFL')\nselected.sp <-  c(\"Canis familiaris\", \n              \"Cuniculus paca\",\n              \"Cuniculus taczanowskii\",\n              \"Dasyprocta fuliginosa\",\n              \"Eira barbara\",\n              \"Herpailurus yagouaroundi\",\n              \"Mazama murelia\",\n              \"Mazama rufina\",\n              \"Mazama zamora\",\n              \"Nasuella olivacea\",\n              \"Odocoileus ustus\",\n              \"Pecari tajacu\",\n              \"Pseudalopex culpaeus\",\n              \"Pudu mephistophiles\",\n              \"Puma concolor\",\n              \"Tapirus pinchaque\",\n              \"Tayassu pecari\",\n              \"Tremarctos ornatus\")\n\n# y.msom <- y[which(sp.codes %in% selected.sp), , ]\n# str(y.msom)\n\n\n#### site covs\nsitecovs <- as.data.frame(st_drop_geometry(\n                    full_sites_14_15_16_sf_UTM[,5:7]))\n sitecovs[, 1] <- as.vector(scale(sitecovs[,1]))   # scale numeric covariates\n sitecovs[, 3] <- as.vector(scale(sitecovs[,3]))   # scale numeric covariates\n # sitecovs$fact <- factor(c(\"A\", \"A\", \"B\"))    # categorical covariate\n\nnames(sitecovs) <- c(\"elev\", \"in_AP\", \"border_dist\")\n\n# check consistancy equal number of spatial covariates and rows in data\n# identical(nrow(ylist[[1]]), nrow(covars)) \n\n# Base de datos para los análisis -----------------------------------------\n\ndata_list <- list(ylist    = ylist, # Historias de detección\n                  siteCovs = sitecovs, #covars, # Covariables de sitio\n                  obsCovs  = list(effort = DetHist_list[[1]]$effort))  # agregamos el esfuerzo de muestreo como covariable de observación\n\n# 3. 1 Modelo multi-especie  -----------------------------------------\n\n# Se creará un txt temporal donde estarán las especificaciones del modelo Bayesiano en JAGS\nmodelfile <- (fileext = \"modoccu.txt\")\n\n# Usaremos la función ` communityModel`\n\n# Generemos el modelo\ncomu_model <- communityModel(data_list, # la lista de datos\n                             occuCovs = list(ranef=c(\"border_dist\", \"elev\", \"in_AP\")), # ranef La covariables de sitio\n                             detCovsObservation = list(fixed = \"effort\"), #Covariables de observación\n                             intercepts = list(det = \"ranef\", occu = \"ranef\"),\n                             # augmentation = c(full = 30),# Número aumentado de especies\n                             modelFile = \"modelfile\")\n\nsummary(comu_model)\n\n\n\n```\n\n### Running the model\n\n```{r}\n# Running the model\n\nfit.commu <- fit(comu_model,\n                 n.iter = 100000,\n                 n.burnin = 10000,\n                 thin = 50,\n                 chains = 3,\n                 cores = 3,\n                 quiet = T\n);beep(sound = 4)\n\n# save the results to not run again\nsave(fit.commu, file=\"C:/CodigoR/Occu_APs/Occu_APs_blog/posts/2nd_model_1AP/result/DR_result.R\") # guardamos los resultados para no correr de nuevo\n```\n### Results as table \n\n```{r}\n\n# Resultados --------------------------------------------------------------\n\n# Extraemos lo tabla de valores estimados\nmodresult <- as.data.frame(summary(fit.commu)[[\"statistics\"]])\n# View(modresult)\nDT::datatable(round(summary(fit.commu)$statistics, 3))\n```\n \n Bayesian p-values can be inspected to check for lack of fit (overall or by species). Lack of fit at significance level = 0.05 is indicated by Bayesian p-values below 0.025 or greater than 0.975. The overall Bayesian p-value (Bpvalue) indicates no problems with lack of fit. Likewise, species-level Bayesian p-values (Bpvalue_species) indicate no lack of fit for any species.\n \n### Results as graph\n\n```{r}\n# Gráficos de predicción y de coeficientes\n\n# Otra gran ventaja de CamtrapR es que permite gráficar de manera muy sencilla la predicción posterior del modelo. Veamos que pasa con la ocupación de cada especie\n\nplot_effects(comu_model,\n              fit.commu,\n              submodel = \"det\",\n             combine = T)\n# $effort\n\n\nplot_coef(comu_model,\n           fit.commu,\n           submodel = \"state\",\n           combine = T)\n# $occupancy\n\n\n\nplot_effects(comu_model, # El modelo\n             fit.commu, # El objeto ajustado\n             submodel = \"state\",\n             response = \"occupancy\") # el parámetro de interés\n#> $rough\n#> \n\n```\n\n\nHere we should see all Rhat values are less than 1.1 and the ESS values indicating adequate mixing of the MCMC chains.\n\n\n\n\n\n\n\n\n## Package Citation\n\n```{r}\n#| code-fold: true\npkgs <- cite_packages(output = \"paragraph\", pkgs=\"Session\", out.dir = \".\")\n# knitr::kable(pkgs)\npkgs\n```\n\n## Sesion info\n\n::: {.callout-note collapse=true}\n```{r}\nprint(sessionInfo(), locale = FALSE)\n```\n:::\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":8,"fig-height":5,"fig-format":"png","fig-dpi":600,"fig-asp":0.618,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"center","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"css":["../../styles.css"],"highlight-style":"arrow","output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.46","lightbox":true,"editor":"visual","theme":{"light":"flatly","dark":"darkly"},"code-block-bg":true,"mainfont":"Fira Sans","title-block-banner":true,"title":"Fitting a Multi-Species non Spatial Occupancy Model","subtitle":"Using Llanganates subset of the WCS camera trap dataset","author":[{"name":"German Forero","orcid":"https://orcid.org/0000-0001-9952-7221"},{"name":"Galo Zapara-Rios","orcid":"https://orcid.org/0000-0003-3508-5078"},{"name":"Diego J. Lizcano","orcid":"https://orcid.org/0000-0002-9648-0576"}],"license":"CC BY-SA","date":"2025-05-17","citation":true,"google-scholar":true,"bibliography":["grateful-refs.bib"],"bibliographystyle":"https://www.zotero.org/styles/tapir-conservation","categories":["model","code","analysis"],"image":"image.png","code-block-border-left":"#31BAE9"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}